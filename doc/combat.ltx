\NeedsTeXFormat{LaTeX2e}
\documentclass[12pt, a4paper]{article}
\usepackage{a4}
\usepackage{vmargin}
\usepackage{times}
%\usepackage{psfig}
\author{Frank Pilhofer\\
fp@fpx.de}
\title{Combat}

\setpapersize{A4}
\setmargrb{2.5cm}{2cm}{2.5cm}{2cm}
\newcommand{\MICO}{\textsc{Mico}}

\begin{document}
\maketitle
\begin{abstract}
The Combat package provides a Tcl language mapping for CORBA, allowing
the implementation of CORBA clients and servers in the Tcl programming
language.

On the client side, Combat is not only useful to easily test-drive
your CORBA servers, but rather makes Tcl an exciting language for
distributed programming. Also, with Tk, you can quickly develop
attractive user interfaces accessing CORBA services. Server-side
scripting using [incr Tcl] classes also offers a wide range of
possibilities.

This document describes the usage of Combat and expects that you are
already familiar with CORBA terminology and concepts.

The most recent version of Combat is always available from its
homepage.\footnote{\texttt{http://www.fpx.de/Combat/}}
\end{abstract}

\newpage
\vfill
\tableofcontents
\vfill
\newpage

\section{Introduction}

Let's begin with an example. A popular one is the ``Account'' example,
in which a Bank supports the \texttt{create} operation to open a new
account. An account, in turn, is an object that supports the
\texttt{deposit}, \texttt{withdraw} and \texttt{balance}
operations. The IDL file could look as follows:

\begin{quote}
\begin{small}
\begin{verbatim}
interface Account {
  void deposit  (in unsigned long amount);
  void withdraw (in unsigned long amount);
  long balance  ();
};
interface Bank {
  Account create (in string name, in string passwd);
};
\end{verbatim}
\end{small}
\end{quote}

Assuming that a server is running, and that an object reference for
the Bank is available in the file ``Bank.ior'' in the current
directory, the following Combat script would connect the bank,
open an account, deposit and withdraw some bucks, and then check its
balance.

\begin{quote}
\begin{small}
\begin{verbatim}
% set Bank [corba::string_to_object file://[pwd]/Bank.ior]
% set Account [$Bank create MyName MyPassword]
% $Account deposit 700
% $Account withdraw 450
% puts "Current balance is $Account balance]."
Current balance is 250.
\end{verbatim}
\end{small}
\end{quote}
%

Here's a list of Combat's main features:

\begin{itemize}
\setlength{\itemsep}{0mm}
\item Client side Tcl scripting
\item Server side Tcl scripting with full POA support
\item Straightforward IDL to Tcl mapping
\item Asynchronous invocations
\end{itemize}

\subsection{Terminology}

Before describing the individual Combat commands, we should define
our terminology.

\begin{description}
\item[Object Reference] ~\newline
An object reference, or IOR (for Interoperable Object Reference) is a
\emph{string} that uniquely identifies a server object. No operations
can be performed upon an IOR directly; it must first be incarnated
into a \emph{handle} using \texttt{corba::string\_\-to\_\-reference}.
\item[Handle] ~\newline
A handle is a Tcl command with the same interface as the server object
as defined in the IDL description. Operations (or the getting/setting
of attributes) on the handle transparently cause a server invocation
to happen. Handles are acquired using
\texttt{corba::string\_\-to\_\-reference} or as a result from a method
invocation.

Handles \emph{must} be stored in a Tcl variable.\footnote{Even when
working interactively.}
\item[Pseudo Object] ~\newline
A pseudo object is, on the outside, not much different from a
handle. However, pseudo objects are local, and an invocation on a
pseudo object does not cause a remote servant to be invoked, but is
processed locally. Combat knows POA, POAManager and POACurrent pseudo
objects. A pseudo object is not associated with an object reference.
\item[Servant] ~\newline
Used in server-side programming. A servant is an
instance of an [incr Tcl] class that inherits directly or
indirectly from \texttt{PortableServer::ServantBase}. Servants are not
CORBA objects; to invoke methods on a servant, one must first obtain
an object reference to the servant using POA functions.
\end{description}

\subsection{Interface Repository}

The Interface Repository is vital for the operation of Combat, and it
is important that you understand its importance. Combat is fully
dynamic and posesses no ``compile-time'' knowledge of object
interfaces. This is different from other language mappings, where
such knowledge is generated by the IDL ``compiler'' in the form of
stubs and skeletons.

Combat instead pulls the information from Interface Repositories, at
runtime. Combat distinguishes between a \emph{local} and many
\emph{remote} repositories. There is at most one local Interface
Repository; this is the one Combat itself is connected to.\footnote{by
performing corba::resolve\_initial\_references
InterfaceRepository} Then, servers themselves can be connected to
different remote Interface Repositories.

For each handle, Combat must find a matching Interface Repository
entry. This is done in the following way:

\begin{enumerate}
\item Object References \emph{optionally} contain a Repository
Id. First of all, Combat looks up that type in the \emph{local}
Interface Repository.\footnote{Unfortunately, there is no standard
CORBA mechanism to access the Repository Id field within an object
reference, so this does not work with Combat's ``Generic ORB''
configuration.}
\item If
\begin{itemize}
\item the Object Reference does not contain a Repository Id,
\item there is no matching record in the local Interface Repository,
or if
\item the user wants to invoke a method that is not available for the
current interface and Combat wants to update its
information,\footnote{It may be that the implementation has been
replaced with a derived type.}
\end{itemize}
a \texttt{\_interface} request\footnote{\texttt{\_interface} is the
GIOP name, elsewhere, it's \texttt{\_get\_interface}.} is sent to the
server. If the server is properly configured, it responds with a
Interface Repository record in a \emph{remote} Interface Repository.
\item Combat uses the identifier of the remote Interface Repository's
record and checks if it is also contained in the local Interface
Repository, which is assumed to be more local and therefore faster. If
the record is found in the local Interface Repository, Combat uses
it, else it keeps the remote information.
\end{enumerate}

It is a problem that, usually, administrative action is necessary for
servers to properly respond to a \texttt{\_interface} request. For
most ORBs, this consists of the following steps:
\begin{enumerate}
\item Start up an Interface Repository server.\footnote{\MICO{}:
\texttt{ird}, ORBacus: \texttt{irserv}}
\item Feed the Interface Repository with IDL files.\footnote{\MICO{}:
\texttt{idl --feed-ir --no-codegen-c++}, ORBacus: \texttt{irfeed}}
\item Connect servers to Interface Repository.
\end{enumerate}
Please see your ORB's documentation for details.

Actually, using remote Interface Repositories by questioning each
object for its own interface information is the ``CORBA'' way to
go. However, there are several reasons why you would want to use a
local Interface Repository:
\begin{itemize}
\item You do not have administrative control over the servers, and
they have not been connected to an Interface Repository, thus failing
to respond to \texttt{\_interface} requests.
\item You have administrative control over the servers, but do not
want to connect them to an Interface Repository because of overhead.
\item It is faster to pull information from a local Interface
Repository than from a remote one.
\end{itemize}
The local Interface Repository, if available, can be administered with
the \texttt{combat::ir} command. A helper program, \texttt{idl2tcl}
exists to generate a string representation of interface data which can
then be used to bootstrap the local Interface Repository. See below
for more information.

Some notes:
\begin{itemize}
\item It is assumed that data in the local Interface Repository does
not conflict data in a remote Interface Repository. If an entry exists
in both, its contents are assumed to be equivalent.
\item For server-side scripting, all necessary interface information
\emph{must} be local.
\item You have a problem if an object reference does not contain
interface information \emph{and} its server is not connected to a
remote Interface Repository -- if Combat does not know the object's
type, it cannot look it up in the local Interface Repository. However,
if you then use the \texttt{\_is\_a} internal operation on the handle,
Combat will associate the object with that type and look it up
locally.
\item \MICO{} automatically provides an empty local Interface
Repository by default, if not overridden. ORBacus does not; if you do
not connect to an Interface Repository upon \texttt{corba::\-init} and
the \texttt{combat::ir} command is used, Combat autostarts an
\texttt{irserv} process and from then on treats it as local.
\item If you have connected to an external Interface Repository upon
\texttt{corba::init}, it may be ``remote'' in the TCP/IP sense, but is
still ``local'' in the Combat sense. In that case, local and remote
Interface Repositories may in fact be the same.
\end{itemize}

Forgive the rather lengthy elaboration. In normal operation, you will
probably never notice the fine distinction between the local and a
remote Interface Repository, but the decision process is important in
case anything does not work as expected.

Hints on debugging Interface Repository problems:
\begin{itemize}
\item Use \texttt{corba::resolve\_initial\_references} to check if a
local Interface Repository is available. (Note that in order to
perform any operations on it, the Interface Repository must contain
information about the Interface Repository's interfaces.)
\item The \texttt{iordump} tool that comes with many ORBs can be used
to check if an object reference does include type information.
\item To check if a remote server supports \texttt{\_interface},
try the internal \texttt{\_get\_interface} operation yourself
(interactively). If you get back a handle, it works, else (if you
receive 0 or an exception) it doesn't.
\end{itemize}

\subsection{Feature Check}

At the beginning of your script, you will have to decide whether
Combat supports your CORBA scripting requirements. This becomes
important if you are working with multiple versions of Combat or with
other CORBA scripting extensions to Tcl. The \texttt{corba::feature}
command exists to verify that necessary optional features are
implemented.

Syntax:
\begin{quote}
\begin{small}
\tt
corba::feature names\\
corba::feature require ?-exact? \emph{feature} ?\emph{version}?
\end{small}
\end{quote}

The ``\texttt{names}'' subcommand returns a list of feature tokens
supported by the implementation. For Combat, this list is \emph{core},
\emph{async}, \emph{callback}, \emph{type},
\emph{poa}\footnote{Only if [incr Tcl] is available}, \emph{register},
\emph{combat::ir} and \emph{mico::bind}\footnote{Only when using the
\MICO{} ORB}.

The ``\texttt{require}'' subcommand has three possible usages. If
called with only a feature token, it succeeds if that feature is
implemented. If that feature is not available at all, an error is
returned. If a version number is mentioned, the command only succeeds
if the implementation provides that feature with the same major number
and at least the same minor number. With the \texttt{-exact} option,
the given version number must match the implemented version exactly.

It is expected that a feature is upwards compatible within the same
major version number, i.e.~version 1.3 supports all operations that
version 1.1 did, but version 2.1 is probably incompatible. Major
version 0 is an exception in that it does not assume backwards
compatibility.

As long as the Tcl language mapping is not official, Combat reports
the version number of the supported features to be the same as the
Combat version (i.e. less than 1.0).

\subsection{Initialization}

Before any of the other commands can be used, Combat and the ORB must
be initialized. This is performed using the \texttt{corba::init}
command.

Syntax:
\begin{quote}
\begin{small}
\tt
corba::init ?\emph{arbitrary-parameters}? ?\emph{ORB-specific-parameters}?
\end{small}
\end{quote}

The command takes an arbitrary number of parameters. Combat itself
does not process any parameters. They are just passed to the ORB's
\texttt{CORBA::ORB\_init()} method; please check your ORB's manual for
a listing of potential options. The ORB will consume all ORB-specific
arguments and remove them from the command line, the remaining
parameters are returned.

It's a good idea to pass a script's command-line arguments, which are
contained in the \texttt{argv} variable, to \texttt{corba::init}. This
can be done using

\begin{quote}
\begin{small}
\begin{verbatim}
set argv [eval corba::init $argv]
\end{verbatim}
\end{small}
\end{quote}
%$

Afterwards, \texttt{argv} contains the remaining options.

Calling \texttt{corba::init} is optional. If not performed explicitly,
it is invoked implicitly with an empty list of arguments if the ORB is
first accessed through any of the other commands.\footnote{Except
\texttt{corba::feature}, which does not require the ORB.}

\section{Client Side scripting}

\subsection{idl2tcl}

As already mentioned above, Combat uses not precompiled stubs but the
Dynamic Invocation Interface for method invocations. In order to
construct a request, information about the available methods and the
types of their parameters is needed. Combat reads this information
from an Interface Repository to typecheck parameter values.

A standalone program, \texttt{idl2tcl} is provided that reads in IDL
files and that produces Tcl declarations that can then be fed into the
local Interface Repository with the \texttt{combat::ir} command (see
below).

Usage:
\begin{quote}
\begin{small}
\tt
idl2tcl ?--name \emph{name}? \emph{idl-file} \dots{}
\end{small}
\end{quote}

The resulting Tcl script is written to a file with the same base name
as the IDL file, but with the \texttt{.tcl} extension, in the current
directory. It can then be read in your own scripts with the
\texttt{source} command, or appropriate portions can be copied and
pasted.

The generated script initializes the Tcl variable
\texttt{\_ir\_\emph{name}} to contain appropriate definitions for the
Interface Repository that can be used in a call to \texttt{combat::ir}
\texttt{add}. In the above variable name, \emph{name} is the base name
of the last IDL input file on the command line, or the parameter given
to the \texttt{--name} option.

Suppose you had a simple IDL file \texttt{hello.idl},
\begin{quote}
\begin{small}
\begin{verbatim}
interface HelloWorld {
  void hello ();
};
\end{verbatim}
\end{small}
\end{quote}

You could then ``compile'' the file to a Tcl definition using

\begin{quote}
\begin{small}
\tt
idl2tcl hello.idl
\end{small}
\end{quote}

In your own scripts, you would initialize the local Interface
Repository using

\begin{quote}
\begin{small}
\tt
source hello.tcl\\
combat::ir add \$\_ir\_hello
\end{small}
\end{quote}

before connecting to any \texttt{HelloWorld} objects.

You may find it interesting that \texttt{idl2tcl} is itself a Combat
program that browses the Interface Repository using self-generated
type information.

\subsection{ORB Methods}

Some basic ORB methods are provided in the \texttt{corba}
namespace. For details, see the CORBA specification, Chapter 4 (``ORB
Interface'').

\begin{quote}
\begin{small}
\tt
corba::string\_to\_object \emph{ior}
\end{small}
\end{quote}

Takes an object reference string as parameter and incarnates into a
new handle.

\begin{quote}
\begin{small}
\tt
corba::object\_to\_string \emph{handle}
\end{small}
\end{quote}

Takes a handle as parameter and returns the stringified IOR of the
associated object reference.

\begin{quote}
\begin{small}
\tt
corba::resolve\_initial\_references \emph{id}
\end{small}
\end{quote}

Obtains an initial reference and incarnates it into a new
handle. Examples include ``RootPOA'', ``POACurrent'',
``InterfaceRepository'' and ``NameService''. For ``RootPOA'' and
``POACurrent'', a pseudo object rather than a ``normal'' handle is
returned.

Note that to access the Interface Repository or the Naming Service,
the Interface Repository must contain appropriate information about
the associated interface.

\begin{quote}
\begin{small}
\tt
corba::list\_initial\_services
\end{small}
\end{quote}

Returns a (potentially incomplete) list of valid ids that can be used
with \texttt{corba::resolve\_\-initial\_\-references}.

\subsection{The MICO Binder}

\begin{quote}
Only supported when Combat is running with \MICO{}.
\end{quote}

To access a service, you need some mechanism to receive its object
references. This can be done by passing IOR strings, or via the Naming
Service. The \MICO{} Binder \footnote{See also the \MICO{} manual.}
can be thought of as a very simple naming mechanism, it searches for a
server based on its Repository Id.

\begin{quote}
\begin{small}
\tt
mico::bind ?-addr \emph{addr}? \emph{repoid} ?\emph{Tag}?
\end{small}
\end{quote}

If no explicit address is given with the \texttt{-addr} option, all
remote ORBs that were given upon initialization (with the
\texttt{-ORBBindAddr} option) are contacted and asked for a server
serving the given Repository Id.

If no \texttt{Tag} (an arbitrary string that may be used to
distringuished different servers serving the same interface) is given,
any such server is acceptable; otherwise, a server object with the
same tag is searched for.

Because this mechanism is \MICO{}-specific, the command resides in the
\texttt{mico::} namespace. You can only bind to servers implemented
with \MICO{}.\footnote{This includes Combat servers, if Combat is
built upon \MICO{}.}

\subsection{Handles}

As already noted, a handle is a Tcl command which you can invoke
available operations, set or query attributes on, as specified
in the IDL description for that particular interface.

\begin{tabular}{ll}
Method invocations: & \texttt{\$obj} \emph{op} \texttt{?parameters ...?} \\
Query attribute:    & \texttt{\$obj} \emph{attribute} \\
Set attribute:      & \texttt{\$obj} \emph{attribute} \emph{value}
\end{tabular}

Invocations are usually synchronous and will wait until the result
from the server is available. See \emph{Asynchronous
Invocations} for information about asynchronous invocations.

An operation is mapped to a Tcl procedure with the same number of
parameters as in the IDL interface description. \texttt{in} parameters
are passed \emph{by value}, as expected, while \texttt{out} and
\texttt{inout} parameters are passed \emph{by reference}. Consider the
operation

\begin{quote}
\begin{small}
\begin{verbatim}
interface A {
  short op (in long val, inout short flags, out string name);
};
\end{verbatim}
\end{small}
\end{quote}

To invoke \texttt{A::op}, you pass the first parameter by value, while
you must put the second parameter in a variable first, and must give a
variable name for the third parameter:

\begin{quote}
\begin{small}
\begin{verbatim}
set flags 42
set res [$Aobj op -1 flags name]
\end{verbatim}
\end{small}
\end{quote}
%$

Note that we did not use \texttt{\$flags} or \texttt{\$name}, and
didn't need to set the \texttt{name} variable prior to the
invocation. Afterwards, you will find in \texttt{flags} and
\texttt{name} the values returned by the operation.

Please see ``The IDL to Tcl mapping'' below for the details about how
CORBA data types are mapped to Tcl.

Each handle also supports the following ``builtin'' operations which
have the same semantics as defined in the CORBA specification.

\begin{description}
\item[\texttt{\_get\_interface}] ~\newline
Returns a handle of type \texttt{CORBA::InterfaceDef} pointing into
the Interface Repository. Since the interface type for handles must be
known, this requires that the IDL description for the Interface
Repository has been loaded into the Interface Repository itself.
\item[\texttt{\_is\_a} \emph{repoid}] ~\newline
Takes a Repository Id as parameter and returns
true (1) if the object implements the given interface.
\item[\texttt{\_non\_existent}] ~\newline
Returns true (1) if the server providing
the implementation for this object has ceased to exist. A false return
value (0) does not guarantee that any following invocations will
succeed.
\item[\texttt{\_is\_equivalent} \emph{handle}] ~\newline
Takes another handle as parameter and returns true (1) if the
objects referenced by both handles are equivalent, or false (0) if
not.
\item[\texttt{\_duplicate}] ~\newline
Returns a duplicate of the handle. See the section about handle
management for more information.
\end{description}

Note that there is no need for an ``is\_nil'' operation, because nil
object references are never incarnated into a handle.

\subsection{Asynchronous Invocations}

As described so far, method (or attribute) invocations are
synchronous, and the invocation blocks until the result (or a success
message) is received from the server. Additional flags can be added
\emph{before the attribute or operation name} to make an invocation
asynchronous.

\begin{quote}
\begin{small}
\tt
\$obj -async \emph{op} ?\emph{parameters} \dots{}? \\
\$obj -callback \emph{proc} \emph{op} ?\emph{parameters} \dots{}?
\end{small}
\end{quote}

With \texttt{-async} or \texttt{-callback}, the invocation does not
wait for the result, but returns immediately. Instead of the
operation's result, an \emph{async-handle} is returned.

\texttt{-callback} arranges for the given procedure to be called once
the server process returns and the result becomes available. The
procedure is called at global level with the handle as single
parameter.

The \texttt{corba::request} command exists to monitor the status of
asynchronous invocations in progress.

Syntax:
\begin{quote}
\begin{small}
\tt
corba::request get \emph{handle} \\
corba::request poll ?\emph{handle} \dots{}? \\
corba::request wait ?\emph{handle} \dots{}?
\end{small}
\end{quote}

\begin{description}
\item[\texttt{get}] ~\newline
Waits until the asynchronous request with the given async-handle has
finished, and returns the result of the operation, or throws an
exception in case of a failure. Also extracts any \texttt{out} or
\texttt{inout} parameters \emph{within the context of the}
\texttt{get} \emph{invocation} (see below).
\item[\texttt{poll}] ~\newline
If called without arguments, it checks
if any of the currently active asynchronous invocations has
finished. If \texttt{poll} is called with one or more handles as
arguments, it checks if any of these has finished. If yes, a single
handle is returned. \texttt{get} should then be called on that handle
to retrieve the result. If none of the (given) request has finished,
\texttt{poll} returns immediately with an empty result.
\item[\texttt{wait}] ~\newline
Similar to \texttt{poll}, but waits until one request has finished and
then returns its handle. If called without arguments, it considers all
asynchronous requests that are in progress. If there are no outstanding
asynchronous requests, it immediately returns with an empty result.
\end{description}

A callback procedure receives a handle as single argument and is
expected to perform a \texttt{corba::request get} on that
handle. Here's a simple example for a callback:

\begin{quote}
\begin{small}
\begin{verbatim}
proc cb {handle} {
  set res [corba::request get $handle]
  puts "Result is: $res"
}
$obj -callback cb sleep 10
\end{verbatim}
\end{small}
\end{quote}
%$

You must be careful using asynchronous invocations for operations with
\texttt{out} or \texttt{inout} parameters. When setting up the
invocation, only the name of the variable that was given for the
\texttt{out} or \texttt{inout} parameter is stored, and they are
written to in the context in which the corresponding
\texttt{corba::request get} is executed. So unless you declare the
variables global inside a callback function, they will not
be visible on the outside. Here's an example. Imagine an object with a
\texttt{strcpy} procedure that takes as parameters an \texttt{out}
string (dest), and an \texttt{in} string.

\begin{quote}
\begin{small}
\begin{verbatim}
proc cb {handle} {
  global dest
  corba::request get $handle
}
global dest
$obj -callback cb strcpy dest "Hello World"
vwait dest
\end{verbatim}
\end{small}
\end{quote}

If \texttt{corba::request get} is executed in the callback procedure,
the \texttt{dest} variable, which is declared to take the \texttt{out}
string parameter to \texttt{strcpy}, is set. If \texttt{dest} were not
declared global, it would be set locally, and the \texttt{vwait} would
block forever.

Notes:
\begin{itemize}
\item The \texttt{-async} and \texttt{-callback} flags can be used
likewise on operations and attributes (for very remote servers,
setting or retrieving an attribute may take some time).
\item Ordering is not guaranteed for asynchronous invocations, not
even on the same object.
\item Asynchronous invocations are only processed in Tcl's event loop,
so if your application isn't event driven, make sure to call
\texttt{update} or \texttt{vwait} once in a while.
\item Pseudo objects support the same syntax for asynchronous
invocations. However, the asynchrony is just ``simulated'' --
operations on pseudo objects always happen synchronously when setting
up the request.
\end{itemize}

\subsection{Accessing Const Values}

Constant values (declared with the IDL keyword \texttt{const}) can be
accessed with the \texttt{corba::const} command:

\begin{quote}
\begin{small}
\tt
corba::const \emph{repoid-or-scoped-name}
\end{small}
\end{quote}

Looks up the constant in the \emph{local} Interface Repository using
either its Repository Id or its scoped  name and returns the
constant's value as an \texttt{Any} value.

\subsection{Handle Management}

There are two commands related to duplicating and releasing
handles. There are subtle differences in handle management depending
on which version of Combat you are using. In Combat/C++, handle
management is fully \emph{automatic}, and you need not spend much
thought on it. In Combat/Tcl, handle management is \emph{manual}.

Combat/C++ automatically releases all memory that is associated with a
handle if the handle is no longer referenced by a Tcl variable. In
Combat/Tcl, you must use \texttt{corba::release} in order to release
all memory. If you want to keep a handle even though it will be
released elsewhere, you must use \texttt{corba::duplicate} to create a
copy. One popular example where duplicates are needed is in a servant,
which receives an object reference as parameter. Because the handle
that is passed as a parameter will be released by the runtime after
the servant's method returns, the servant must create a duplicate in
order to keep a copy.

\begin{quote}
\begin{small}
\tt
corba::duplicate ?\emph{typecode}? \emph{value}
\end{small}
\end{quote}

The \texttt{corba::duplicate} command takes a value as parameter, and
optionally a typecode. If the typecode is omitted, then \emph{value}
must be a handle. This handle is then duplicated, and a new handle
that encapsulates the same object reference as the original, is
returned. If a typecode is present, then \emph{value} must match that
typecode. The command will then traverse the value according to the
typecode and duplicate all of its handles. A ``deep copy'' is then
returned.

\begin{quote}
\begin{small}
\tt
corba::release ?\emph{typecode}? \emph{value}
\end{small}
\end{quote}

The syntax of \texttt{corba::release} is the same as
\texttt{corba::duplicate}. If the typecode is omitted, then
\emph{value} must be a handle. All memory that the ORB associates with
this handle is released, and no further invocations using this handle
are possible. If a typecode is present, then \emph{value} must match
that typecode. The command will then traverse the value according to
the typecode and release all of its handles.

Since handle management in Combat/C++ is automatic, both of these two
commands exist in Combat/C++ for compatibility only.

\subsection{Dynamic Invocations}

Invocations normally pull type information from the Interface
Repository. In contrast, an invocation using \textbf{corba::dii} does
not require type information for the remote interface to be present in
the Interface Repository; here, type information is passed along with
each invocation in a separate \emph{spec} parameter:

\begin{quote}
\begin{small}
\tt
corba::dii \emph{handle} \emph{spec} ?\emph{parameters} \dots{}?
\end{small}
\end{quote}

\emph{spec} is a list composed of three or four elements. The first
element is the typecode of the return value. The second element is the
name of the operation to be invoked. The third element describes the
parameters. The fourth element is a list of exception typecodes that
this operation may throw. The parameter description is a list that
contains one element per parameter. Each parameter is described by a
list of two elements. The first element is either \textbf{in},
\textbf{out} or \textbf{inout}, and the second element is the typecode
of the parameter type.

As described in the section about asynchronous invocations, you can
also use the \textbf{-async} or \textbf{-callback} option to initiate
a dynamic invocation asynchronously.

\section{The IDL to Tcl mapping}

\subsection{Mapping of Data Types}

This section describes how IDL data types are mapped to Tcl types.

\begin{description}
\item[Primitive Types] ~\newline
\texttt{short}, \texttt{long}, \texttt{unsigned short},
\texttt{unsigned long}, \texttt{long long} and \texttt{unsigned long
long} values are mapped to Tcl's integer type. Errors may occur if a
value exceeds the numerical range of Tcl's integer type.

\texttt{float}, \texttt{double}, \texttt{long double} values are
mapped to Tcl's floating point type.

\texttt{string} and \texttt{wstring} values are mapped to Tcl strings.

\texttt{boolean} values are accepted as 0, 1, true, false, yes and
no. In a result, they are always rendered as 0 (false) and 1 (true).

\texttt{octet}, \texttt{char} and \texttt{wchar} values are mapped to
strings of length 1.

\texttt{fixed} values are mapped to a floating-point value in
exponential representation. Depending on their scale and value, it may
or may not be possbile to use the value in a Tcl expression.

\item[Struct Types] ~\newline
\texttt{struct} values are mapped to a list. For each element in
the structure, there are two elements in the list -- the first is
the element name, the second is the element's value. This allows to
easily assign structures from and to associative arrays, using
\texttt{array get} and \texttt{array set}.

Example: the IDL type
\begin{quote}
\begin{small}
\begin{verbatim}
struct A {
  unsigned long B;
  string C;
};
\end{verbatim}
\end{small}
\end{quote}
can be matched by the Tcl list \texttt{\{B 42 C \{Hello
World\}\}}.

\item[Sequences] ~\newline
\texttt{sequence} values are mapped to a list. As an exception,
sequences of \texttt{char}, \texttt{octet} and \texttt{wchar} are
mapped to strings.

Example: the IDL type (following the above example for a structure)
\begin{quote}
\begin{small}
\begin{verbatim}
typedef sequence<A, 2> D;
\end{verbatim}
\end{small}
\end{quote}
can be matched by the Tcl list \texttt{\{\{B 42 C \{Hello
World\}\}\}}. Note the extra level of nesting compared to the struct
above.

\item[Arrays] ~\newline
\texttt{array} values are mapped to a list. As an exception,
sequences of \texttt{char}, \texttt{octet} and \texttt{wchar} are
mapped to strings.

\item[Enumerations] ~\newline
\texttt{enum} values are mapped to the enumeration identifiers
(without any namespace qualifiers).

Example: the IDL type
\begin{quote}
\begin{small}
\begin{verbatim}
enum E {F, G, H};
\end{verbatim}
\end{small}
\end{quote}
can be matched by the Tcl string \texttt{G}.

\item[Unions] ~\newline
\texttt{union} values are mapped to a list of length 2. The first
element is the discriminator, or \texttt{(default)} for the default
member. The second element is the appropriate union member. Note that
the default case can also be represented by a concrete value distinct
from all other case labels.

\item[Object References] ~\newline
Non-nil object references are mapped to handles. Nil object references
are mapped to the integer value 0 (zero).

\item[Exceptions] ~\newline
\texttt{exception} values are mapped to a list of length one or
two. The first element is the Repository Id for the exception. If
present, the second element is the exception's contents, equivalent to
the structure mapping. The second element may be omitted if the
exception has no members.

\item[Value Types] ~\newline
\texttt{valuetype} values are mapped to a list, like
\texttt{structs}. For each element in the inheritance hierarchy of a
\texttt{valuetype}, there are two elements in the list -- the first is
the element name, and the second is the element's value. An additional
member \texttt{\_tc\_} may be present. If present, its value must be a
typecode. In an invocation, this member determines the type to be
sent. This mechanism allows to send a derived valuetype where a base
valuetype is expected. If no \texttt{\_tc\_} member is present, the
valuetype must be of the same type as requested by the parameter. In
receiving a valuetype, the \_tc\_ member is always added. A
\texttt{valuetype} can also be the integer 0 (zero) for a null
value.

Note that this language mapping disallows valuetypes that contain
themselves.

\texttt{custom} valuetypes are not supported.

\item[Value Boxes] ~\newline
Boxed \texttt{valuetype} types are mapped to either the boxed type or
to the integer 0 (zero) for a null value. In the case of boxed
integers, the value 0 will always be read as a null value rather than
a non-null value containing the boxed integer zero. Shoot yourself in
the foot if you run into this problem.

\item[TypeCode values] ~\newline
\texttt{TypeCode} values are mapped to a string containing a
description of the typecode:
\begin{itemize}
\item Typecodes for the primitive types \texttt{void},
\texttt{boolean}, \texttt{short}, \texttt{long}, \texttt{unsigned
short},\texttt{unsigned long}, \texttt{long long}, \texttt{unsigned
long long}, \texttt{float}, \texttt{double}, \texttt{long double},
\texttt{char}, \texttt{octet}, \texttt{string}, \texttt{any},
\texttt{TypeCode} are mapped to their name.
\item Bounded string typecodes are mapped to a list of length two. The
first element of the list is the identifier \texttt{string}, the
second element is the bound.
\item Bounded wstring typecodes are mapped to a list of length
two. The first element of the list is the identifier \texttt{wstring},
the second element is the bound.
\item \texttt{struct} typecodes are mapped to a list of length
three. The first element is the identifier \texttt{struct}. The second
element is the Repository Id, if available (else, the field may be
empty). The third element is a list with an even number of
elements. The zeroth and other even-numbered elements are member
names, followed by the member's typecode.
\item \texttt{union} typecodes are mapped to a list of length
four. The first element is the identifier \texttt{union}. The second
element is the Repository Id, if available (else, the field may be
empty). The third element is the typecode of the discriminator. The
fourth element is a list with an even number of elements. The zeroth
and other even-numbered elements are labels or the identifier
\texttt{default} for the default label, followed by the typecode of
the associated member.
\item \texttt{exception} typecodes are mapped to a list of length
three. The first element is the identifier \texttt{exception}, the
second element the Repository Id, and the third element is a list with
an even number of elements. The zeroth and other even-numbered
elements are member names, followed by the member's typecode.
\item \texttt{sequence} typecodes are mapped to a list of length two
or three. The first element is the identifier \texttt{sequence}, the
second element is the typecode of the member type. The third element,
if present, denotes the sequence's bound. Otherwise, the sequence is
unbounded.
\item \texttt{array} typecodes are mapped to a list of length
three. The first element is the identifier \texttt{array}, the second
element is the typecode of the member type, the third element is the
array's length.
\item \texttt{enum} typecodes are mapped to a list of length two. The
first element is the identifier \texttt{enum}, the second element is a
list of the enumeration identifiers.
\item Object reference typecodes are mapped to a list of length
two. The first element is the identifier \texttt{Object}, the second
element is the Repository Id of the IDL \texttt{interface}.
\item \texttt{fixed} typecodes are mapped to a list of length
three. The first element is the identifier \texttt{fixed}. The second
element is the number of significant digits, the third element is the
scale.
\item \texttt{valuetype} typecodes are mapped to a list of length
five. The first element is the identifier \texttt{valuetype}. The
second element is the Repository Id. The third element is a list of
non-inherited members. For each member, there are three elements in
the list, a visibility (\texttt{private} or \texttt{public}), the
member name and the member's typecode. The fourth element is the
typecode of the valuetype's concrete base, or 0 (zero) if the
valuetype does not have a concrete base. The fifth element is either
an empty string or one of the modifiers \texttt{custom},
\texttt{abstract} or \texttt{truncatable}.
\item Boxed \texttt{valuetype} typecodes are mapped to a list of
length 3. The first element is the identifier \texttt{valuebox}. The
second element is the Repository Id, and the third element is the
typecode of the boxed type.
\item A recursive reference to an outer type (in a \texttt{struct},
\texttt{union} or \texttt{valuetype}) can be expressed by a list of
length two. The first element is the identifier \texttt{recursive},
the second element is the Repository Id of the outer type, which must
appear in the same typecode description.
\end{itemize}
Examples for legal TypeCodes are:
\begin{itemize}
\item \texttt{struct \{\} \{s short ul \{unsigned long\} Q string\}}
\item \texttt{enum \{A B C\}}
\item \texttt{union \{\} short \{0 boolean (default) string\}}
\item \texttt{struct IDL:S:1.0 \{foo \{sequence \{recursive IDL:S:1.0\}\}\}}
\end{itemize}
See the description of \texttt{corba::type}. The \texttt{of}
subcommand can be used to retrieve TypeCode information from the
Interface Repository, the \texttt{equivalent} subcommand can be used
to check TypeCode values against known types.

\item[Any values] ~\newline
\texttt{any} values are mapped to a list of length two. The first
element is the typecode, and the second element is the value.
\end{description}

\subsection{Exceptions}

\subsubsection{Throwing Exceptions}

Exceptions can be thrown with the \texttt{corba::throw} command.

Syntax:
\begin{quote}
\begin{small}
\begin{verbatim}
corba::throw <exception>
\end{verbatim}
\end{small}
\end{quote}

The parameter must be an exception according to the mapping above: a
list of length one or two. The first element of the list is the
exception's Repository Id. The second element is a list of the
exception's members according to the mapping for structures. If the
following two exceptions were declared in interface A,

\begin{quote}
\begin{small}
\begin{verbatim}
interface A {
  exception EX {
    long value;
    string reason;
  };
  exception OOPS {};
};
\end{verbatim}
\end{small}
\end{quote}

then these would be legal invocations of \texttt{corba::throw}

\begin{quote}
\begin{small}
\begin{verbatim}
corba::throw {IDL:A/EX:1.0 {value 42 reason "oops, what's up?"}}
corba::throw IDL:A/OOPS:1.0
\end{verbatim}
\end{small}
\end{quote}

The exception must be known to the \emph{local} Interface Repository,
where the given Repository Id is looked up.\footnote{With the
exception of system exceptions.} In the second example, the
exception's members could be omitted because the exception does not
have any members.

If this command is used in a servant in the context of a server
invocation, and if the exception is not caught within the servant, it
is passed back to the client side. If an exception is not caught
within a client, the client prints an error message and terminates.

\subsubsection{Catching Exceptions}

Exceptions can be caught with Tcl's \texttt{catch} command. See the
Tcl manual page for details.

\begin{quote}
\begin{small}
\begin{verbatim}
catch {
    ... object invocations that might throw exceptions ...
} result
\end{verbatim}
\end{small}
\end{quote}

If this command returns 0, the script has completed successful, without
throwing an exception, and result contains the script's return code. If
\texttt{catch} returns 1, an error has happened, and the error code is
stored in the result variable.

A small problem is that not all errors are exceptions, so you will have
to check the result from \texttt{catch} carefully if it contains an
exception or other error information. You should check the first item
of the result if it is a known exception's Repository Id.

For convenience, you can also use the \texttt{corba::try} command to
handle exceptions. It implements Java-style processing of exceptions.

Syntax:
\begin{quote}
\begin{small}
\begin{verbatim}
corba::try block ?catch {repoid ?var?} c-block? ... ?finally f-block?
\end{verbatim}
\end{small}
\end{quote}

First, the code block \texttt{block} is evaluated. If a CORBA exception
or Tcl error has occured, then the \texttt{catch} clauses are searched
left to right. Each \texttt{catch} clause is associated with a
Repository Id and a code block. For the first clause whose Repository
Id matches the Repository Id of the exception that has occured, the
associated code block is executed.

The special value \texttt{...} for a Repository Id in a \texttt{catch}
clause is recognized to match all CORBA exceptions and Tcl errors.

If a variable name is associated with the Repository Id in a
\texttt{catch} clause, this variable is set to the exception that has
occured during execution of the associated code block.

Regardless of whether an exception or error has occured and whether an
exception or error has indeed been handled by a \texttt{catch} clause,
the code block associated with the \texttt{finally} clause is, if it
exists, always executed.

If there are no \texttt{catch} clauses, an implicit clause that catches
\texttt{...} is used.

The return value of the \texttt{corba::try} statement is computed as
follows, in order of priority:
\begin{itemize}
\item If a \texttt{finally} clause exists and its associated code
block completes with a return value different from \texttt{TCL\_OK}
(i.e.~causes itself an error or executes a Tcl \texttt{return},
\texttt{break} or \texttt{continue} statement), then this return code
is used.
\item If a CORBA exception or Tcl error occurs while executing the
``main'' code block, and this exception or error is handled by a
\texttt{catch} clause, then the return value of the associated code
block for this clause is used.
\item If a CORBA exception or Tcl error occurs while executing the
``main'' code block, and this exceptions is not handled by a
\texttt{catch} clause, then this error is used.
\item If no CORBA exception or Tcl error occurs while executing the
``main'' code block, then its return code is used.
\end{itemize}

One effect of this return value handling is that all code blocks may
execute a Tcl \texttt{return}, \texttt{break} or \texttt{continue}
statement, which will then be correctly passed along to the
surrounding code.

\subsubsection{Exception Example}

Here's an example how exceptions could be handled:

\begin{quote}
\begin{small}
\begin{verbatim}
corba::try {
   ...
} catch {IDL:A/EX:1.0 oops} {
  # oops contains A::EX data
} catch {IDL:omg.org/CORBA/COMM_FAILURE:1.0} {
  # remote server may be down
} catch {... oops} {
  puts "oops: unexpected exception: $oops"
}
\end{verbatim}
\end{small}
\end{quote}
%$

\subsection{Working with TypeCodes}

The \texttt{corba::type} command can be used to ensure type safety.

\begin{description}
\item[\texttt{corba::type of <repoid-or-scoped-name>}] ~\newline
When given the Repository Id or scoped name of any type (such as a
struct), this command retrieves the type code from the \emph{local}
Interface Repository.
\item[\texttt{corba::type match <TypeCode> <value>}] ~\newline
If the value matches the type code, this command returns 1, otherwise
0. This enables applications to verify type-safety of operation
parameters or type-safe composition of Any values.
\item[\texttt{corba::type equivalent <TypeCode> <TypeCode>}] ~\newline
Type codes can be compared for identity using string comparison. This
method is a less strict comparison and returns 1 if both types are
equivalent, meaning that they accept the same values (for example,
they ignore type aliasing). This information can for example be used
to extract values from an Any, by comparing the Any's type code
against known (expected) type codes.
\end{description}

\section{The Interface Repository}

Combat provides the \texttt{combat::ir} command to access the Interface
Repository, which resides in the \texttt{combat} namespace because it
is specific to the Combat package. You have already learned one usage
of this command when bootstrapping a local Interface Repository with
information about the interfaces generated by \texttt{idl2tcl}.

Syntax:
\begin{quote}
\begin{small}
\tt
combat::ir add \emph{ir-description-seq}
\end{small}
\end{quote}

This adds new entries to the \emph{local} Interface Repository.
\texttt{ir-description-seq} must be a string generated by
\texttt{idl2tcl}. In case of duplicates, existing entries in
the Interface Repository are overwritten, while modules and interfaces
are reopened and added to.

\section{Server Side Scripting}

\subsection{Implementing Servants}

The server-side mapping is kept similar to the C++ mapping in that it
is based on the POA and associated interfaces. Servants are realized
using [incr Tcl] classes. Previous exposure to [incr Tcl] is useful,
but not required.

To implement a servant, you must write an [incr Tcl] class that
inherits, directly or indirectly, from the Combat-provided class
\texttt{PortableServer::ServantBase}. In the implementation, you must
provide public variables for IDL attributes and a public method for
IDL operations, all with the same name as in the IDL file.

As a little piece of magic, since Combat does not have compile-time
type information, you must provide run-time type information. This is
done by implementing the public method \texttt{\_Interface} (leading
underscore, capital I), which does not have any parameters and must
return the Repository Id for the servant's most-derived IDL
interface.

\begin{quote}
Important note: Type information for all interfaces \emph{must} be
contained in the \emph{local} Interface Repository!
\end{quote}

As an example, consider the following IDL file:

\begin{quote}
\begin{small}
\begin{verbatim}
interface Foo {
  void HelloWorld ();
  attribute short x;
};
\end{verbatim}
\end{small}
\end{quote}

Its implementation could look like

\begin{quote}
\begin{small}
\begin{verbatim}
class Foo {
  inherit PortableServer::ServantBase

  public method _Interface {} {
    return "IDL:Foo:1.0"
  }

  public method HelloWorld {} {
    puts "Hello World"
  }

  public variable x
}
\end{verbatim}
\end{small}
\end{quote}

As with method invocations, \texttt{in} parameters are
passed by value, while \texttt{out} and \texttt{inout} parameters are
passed by reference. Consider the operation

\begin{quote}
\begin{small}
\begin{verbatim}
interface A {
  short op (in long val, inout short flags, out string name);
};
\end{verbatim}
\end{small}
\end{quote}

In your implementation, you receive variable names for the
\texttt{flags} and \texttt{name} parameters. However, since these
variables are set ``outside'' your class method, i.e. one level
``above'', you must ``import'' them using \texttt{upvar} (see the Tcl
manual). Therefore, an implementation for the above method could look
like

\begin{quote}
\begin{small}
\begin{verbatim}
class A {
  inherit PortableServer::ServantBase

  public method _Interface {
    return "IDL:A:1.0"
  }

  public method op { val flags_name name_name } {
    upvar $flags_name flags $name_name name
    puts "val is $val"
    puts "flags is $flags"
    set flags -1
    set name "Hello World"
    return 42
  }
}
\end{verbatim}
\end{small}
\end{quote}

Now that we have written an implementation, we can create an instance
of that class (``Servant'') using

\begin{quote}
\begin{small}
\begin{verbatim}
set serv [Foo #auto]
\end{verbatim}
\end{small}
\end{quote}

Servant memory mangement is left entirely to the user. Servants are
allocated and deleted using the above construction mechanism and [incr
Tcl]'s \texttt{delete} operator. The application is responsible not to
delete any servants that are still referenced in a POA.

Servants are not automatically accessible from the outside after their
creation. They must be \texttt{activated} in a POA first.

Each servant inherits the \texttt{\_this} member function, which has
three purposes (the same as in the C++ mapping).
\begin{enumerate}
\item Within the context of a request invocation, returns a new handle
incarnating a reference for the object that the servant currently
incarnates.
\item Outside the context of a request invocation, if the servant
has not yet been activated, and if its POA has the
\texttt{IMPLICIT\_ACTIVATION} policy, the servant is activated, and a
handle incarnating an object reference to that servant is returned.
\item Outside the context of a request invocation, if the servant has
already been activated, and if its POA has the
\texttt{UNIQUE\_ID} policy, a handle incarnating an object reference
to that servant is returned.
\end{enumerate}

\subsection{The POA Pseudo Object}

A pseudo object for the Root POA is obtained using
\texttt{corba::resolve\_initial\_references}:

\begin{quote}
\begin{small}
\begin{verbatim}
set RootPOA [corba::resolve_initial_references RootPOA]
\end{verbatim}
\end{small}
\end{quote}

POA pseudo objects support all operations as defined in the CORBA
specification. The usual type mapping rules apply, with a single
exception. The \texttt{create\_POA} method receives as its second
parameter a list of policy \emph{values} rather than a list of policy
\emph{objects}. That means that the corresponding factory operations,
like \texttt{create\_\-lifespan\_\-policy} are not needed. Example:

\begin{quote}
\begin{small}
\begin{verbatim}
set myPOA [$RootPOA create_POA 0 {USE_SERVANT_MANAGER PERSISTENT}]
\end{verbatim}
\end{small}
\end{quote}
%$

This creates a new POA as a child of the Root POA. A new POA Manager
is created, because a nil value rather than a handle is passed as the
first parameter. The new POA will support persistent objects and use a
servant manager.

The ``native'' data types from the POA specification are represented
in the following way:

\begin{description}
\item[PortableServer::Servant] ~\newline
Servants are instances of an [incr Tcl] class that derives from
\texttt{PortableServant::\-ServantBase}, as seen above.
\item[PortableServer::ObjectId] ~\newline
ObjectIds are mapped to Tcl strings.
\item[PortableServer::ServantLocator::Cookie] ~\newline
Cookies are mapped to Tcl strings.
\end{description}

\subsection{The POA Current Pseudo Object}

A POA Current pseudo object is obtained using
\texttt{corba::resolve\_initial\_re\-feren\-ces}.

\begin{quote}
\begin{small}
\begin{verbatim}
set POACurrent [corba::resolve_initial_references POACurrent]
\end{verbatim}
\end{small}
\end{quote}

A POA Current pseudo object implements all operations as defined in
the CORBA specification:

\begin{description}
\item[\texttt{get\_POA}] ~\newline
In the context of a method invocation on a servant, returns the POA in
whose context it is called.
\item[\texttt{get\_object\_id}] ~\newline
In the context of a method invocation, returns the Object Id
identifying the object in whose context it is called.
\end{description}

\subsection{The POA Manager Pseudo Object}

A POA Manager pseudo object is obtained using the
\texttt{the\_POAManager} method on a POA pseudo object. It implements
the following methods as defined in the CORBA specification:

\begin{description}
\item[\texttt{activate}] ~\newline
Switches all associated POAs to the ``active'' state so that they can
start serving requests.
\item[\texttt{hold\_requests} \emph{wait\_for\_completion}] ~\newline
Switches all associated POAs to the ``holding'' state, so that
incoming method invocations are queued. Queued requests are performed
when the POA again enters the active state.
\item[\texttt{discard\_requests} \emph{wait\_for\_completion}] ~\newline
Switches all associated POAs to the ``discarding'' state, so that
incoming method invocations are discarded rather than processed.
\item[\texttt{deactivate} \emph{etherealize} \emph{wait\_for\_completion}] ~\newline
Switches all associated POAs to the ``inactive'' state. If
\emph{etherealize} is true, a servant manager, if available, is asked
to ``etherealize'' active objects.
\end{description}

\subsection{Examples}

While implementing servants should be pretty straightforward, the
number of possibilities for handling servants with the POA is pretty
confusing. Let's write a simple servant, and then try a few examples.
In the following examples, we assume that you have ``compiled'' the
IDL file into a Tcl file using \texttt{idl2tcl}, that you have sourced
that file and fed the local Interface Repository.

The ``Hello World'' IDL definition:
\begin{quote}
\begin{small}
\begin{verbatim}
interface HelloWorld {
  void hello ();
};
\end{verbatim}
\end{small}
\end{quote}

The ``Hello World'' implementation:
\begin{quote}
\begin{small}
\begin{verbatim}
class HelloWorld {
  inherit PortableServer::ServantBase

  public method _Interface {} {
    return "IDL:HelloWorld:1.0"
  }

  public method hello {} {
    puts "Hello World"
  }
}
\end{verbatim}
\end{small}
\end{quote}

Now, the following few lines of code create a Hello servant,
activate it with the POA and starts serving request.

\begin{quote}
\begin{small}
\begin{verbatim}
set poa [corba::resolve_initial_references RootPOA]
set mgr [$poa the_POAManager]

set serv [Hello #auto]

$poa activate_object $serv
$mgr activate
vwait forever
\end{verbatim}
\end{small}
\end{quote}

First, we obtain the POA and POAManger pseudo objects. Then, we
create an instance of the ``Hello'' class and activate it using
the \texttt{activate\_object} method on the POA. Then, we use
\texttt{activate} on the POA Manager to transition the POA from its
initial Holding to the active state. Last, we enter Tcl's event loop
by waiting for the \texttt{forever} variable to change, which never
happens -- so Tcl never returns from the event loop and will
process requests forever.

As an alternative to \texttt{activate\_object}, we could also use
\texttt{servant\_to\_id}. Since the Root POA has the
\texttt{IMPLICIT\_ACTIVATION} policy, it would cause the servant to be
implicitely activated.

Another alternative is to call the servant's inherited \texttt{\_this}
member function, which also implicitely activates a servant.

Now let's assume we want to activate more than one Hello servant, and
we want to assign each servant an Object Id of our choice, so that
clients can bind to a specific servant. Since the RootPOA has the
\texttt{SYSTEM\_ID} policy, this involves creating a new POA that has
the \texttt{USER\_ID} policy.

\begin{quote}
\begin{small}
\begin{verbatim}
set poa   [corba::resolve_initial_references RootPOA]
set mgr   [$poa the_POAManager]
set mypoa [$poa create_POA MyPOA $mgr {USER_ID}]

set serv1 [Hello_impl #auto]
set serv2 [Hello_impl #auto]

$mypoa activate_object_with_id Hello-1 $serv1
$mypoa activate_object_with_id Hello-2 $serv2
$mgr activate
vwait forever
\end{verbatim}
\end{small}
\end{quote}

For a more complex example, see the server of the Bank/Account example
in the \texttt{demo/account} subdirectory. There,
\texttt{create\_reference\_with\_id} is used in the Bank factory to
create references to non-existent Account objects. A Servant Activator
is then registered to create Accounts on demand.

\subsection{Limitations}

Because [incr Tcl] currently does not support virtual inheritance,
Combat does not support multiple inheritance yet.

However, single implementation inheritance works, you can simply
inherit from the base implementation instead of
\texttt{PortableServer::ServantBase}.

\section{To Do}

Combat seems reasonably complete. Some random leftover thoughts:
\begin{itemize}
\item Multithreading is not yet supported. It might work if Combat
commands are only used from a single thread, but this is untested.
If multithreading was supported, would it eliminate the need for
asynchrony?
\item Should [incr Tcl] be replaced on the server side? It's basically
nice, but does not support diamont inheritance, and does not allow for
reference-counted objects.
\item Maybe interface information could be stored elsewhere than in
the Interface Repository, for example by storing
\texttt{FullInterfaceDescription} data. This would improve things with
ORBs that do not provide an ``internal'' IFR.
\item It would be wonderful to submit the interfaces and mappings in
this document as an official OMG language mapping. I do not have the
authority and muscle to do that on my own.
\end{itemize}

Note that the author's motivation in further development of Combat is
partly fueled by user feedback. I would love to hear of projects using
Combat, or of plans to use it.

\end{document}
